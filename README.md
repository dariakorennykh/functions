# functions
Функция - часть программы, блок кода, имеющий своё название. Большая программа может строиться из нескольких функций, каждая из которых выполняет свою задачу, поэтому можно назвать функцию подпрограммой. Использование функций очень сильно упрощает написание и чтение кода, и в большинстве случаев делает его оптимальным по объёму занимаемой памяти. Функция должна быть описана, и после этого может вызываться. Функция должна быть описана снаружи других функций! В общем виде функция имеет следующую структуру:
Функция, которая ничего не принимает и ничего не возвращает
Самый простой для понимания вариант, с него и начнём. Помимо типов данных, которые я перечислял в уроке о типах данных, есть ещё один - void, который переводится с английского как "пустота". Создавая функцию типа void мы указываем компилятору, что никаких значений возвращаться не будет (точнее будет - функция вернёт "ничего").

В некоторых языках программирования есть понятие "процедура" - это как раз и есть функция, которая ничего не принимает и не возвращает. Но в C++ такого понятия нет, есть только функции.

Функция, которая ничего не принимает и возвращает результат
Чтобы функция могла вернуть численное значение, она должна быть описана с типом данных, который будет возвращаться. Нужно заранее подумать, какой тип будет возвращён, чтобы избежать ошибок. Например я знаю, что моя суммирующая функция работает с типом данных byte, она складывает два таких числа. Это означает, что результат вполне может превысить предел типа byte (сложили 100 и 200 и получили 300), значит функции следовало бы возвращать например тип данных int. Собственно поэтому у переменной c из предыдущего примера тип данных int.

Для возврата значения нам понадобится оператор return, который и будет возвращать число. Здесь нужно запомнить, что return не просто возвращает значение, а также завершает выполнение функции, то есть действия, указанные после return, выполнены уже не будут! На самом деле это очень удобно, ведь с помощью логических конструкций и операторов выбора можно предусмотреть в функции несколько разных return, которые будут возвращать разные значения или просто завершать выполнение функции.

Функция типа void вроде бы ничего не возвращает, но использование return; позволяет завершить выполнение функции по условию или как-то ещё. Это очень удобно!
Функция, которая принимает аргументы и возвращает результат
Что касается аргументов, то они перечисляются в скобках через запятую с указанием типов данных. При вызове функции указанные аргументы превращаются в локальные переменные, с которыми можно работать внутри функции. Иными словами - это копии переданных переменных! При вызове функции эти переменные получают значения, которые мы указываем при вызове. 

Функция, которая меняет значение переменных
Забегая немного вперёд (в урок про указатели и ссылки) сразу рассмотрим ещё один полезный вариант: функция меняет значения указанных переменных. В рассмотренных выше примерах мы передавали в функцию переменные по значению. Это означает, что внутри тела функции мы имеем дело с копиями переменных, которые не влияют на изначальные переменные. Если передать переменную по ссылке - внутри функции мы будем работать именно с теми переменными, которые передали в качестве аргументов! Для передачи аргумента по адресу достаточно добавить всего лишь один символ - &. Напишем функцию, которая увеличивает значение переданной переменной на 10

Типы данных
Функция может возвращать и принимать как аргумент любые типы данных в любых сочетаниях: целые числа, float, String, указатели, struct, enum и так далее. Например следующая функция принимает два числа, склеивает их в строку через запятую и возвращает:

Как вернуть несколько значений?
В языке C++, в отличие от того же Питона, нельзя просто так взять и вернуть из функции два значения. К слову, принять их тоже нельзя, такого механизма в языке нет. Но есть структуры! Функция может принять структуру, вернуть структуру, а мы можем присвоить структуру. Давайте сделаем функцию, которая принимает два числа, находит их сумму, разность и произведение и возвращает результат в виде структуры. Для начала опишем структуру:

Описание и реализация
Хорошим тоном считается объявлять функции отдельно от реализации. Что это значит: в начале документа, или в отдельном файле, мы описываем функцию (это будет называться прототип функции), а в другом месте пишем реализацию. Так делают в серьёзных программных проектах, Ардуино-библиотеки - не исключение. Также такое написание позволяет слегка ускорить компиляцию кода, потому что компилятор уже знает, что он в нём найдёт. Алгоритм такой

Передача массива в функцию (Pro)
Иногда бывает нужно передать в функцию массив (мы о них уже говорили), передать именно массив целиком, а не отдельный его элемент. В этом случае уже не обойтись без указателей (урок про указатели). В следующем примере наша функция sumFunction будет суммировать элементы массива, который в неё передаётся. Функция заранее знает, сколько в массиве элементов, потому что я явно цифрой указал количество в цикле for.

*****Важно! Переданный в функцию массив не дублирует исходный массив! Любые действия, совершённые с переданным массивом, влияют на "оригинальный" массив!*****

Другие типы функций (Pro)
Шаблонные функции
Шаблон - ещё один мощный инструмент языка C++, позволяющий создавать алгоритмы без привязки к типам данных. Тема очень обширная, мы рассмотрим её только применительно к "универсальным" функциям, полностью про шаблоны можно почитать тут, и тут продолжение.

Итак, шаблонные функции. В примере выше мы использовали перегруженные функции для создания функций с одинаковым именем, но разным типом передаваемых аргументов. При помощи шаблонов можно сделать одну функцию, которая будет работать для любых типов данных! Компилятор сам выберет, какие типы данных подставить в функцию на этапе компиляции и создаст несколько перегруженных функций, если это нужно.
Макро-функции
Вы наверное уже помните такую директиву препроцессора, как #define. Из урока про переменные и константы мы узнали, что при помощи дефайна можно задавать константы. Ключевая особенность работы #define заключается в том, что он заменяет последовательность символов чем угодно, что мы там напишем, и это даёт возможность создавать так называемые макро-функции (macro), которые не создаются как функции, а вставляются в код при компиляции. Например вот так будет выглядеть макро, складывающая два числа

*****"Аргументы" макро-функции нужно обязательно заключать в скобки (как (x)+(y) выше), иначе работа макроса может быть непредсказуемой, если в качестве аргумента подать не одно число, а выражение.
Также всё тело макро функции желательно брать в скобки, ( (x) + (y) ) как выше, иначе можно напороться на неприятную ситуацию с порядком вычисления. Например в коде мы используем sum(x, y) * 5. Макрос развернётся в (x + y) * 5. Если у тела макроса не будет скобок, то получится x + y * 5, что имеет абсолютно другой смысл!*****

